import org.w3c.dom.Document
import org.w3c.dom.Element
import org.w3c.dom.NodeList

import javax.xml.parsers.DocumentBuilder
import javax.xml.parsers.DocumentBuilderFactory

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.apache.commons:commons-io:1.3.2'
    }
}

configurations {
    jacocoant
    jacoco
    antjunit
}

dependencies {
    jacoco 'org.jacoco:org.jacoco.agent:0.6.2.201302030002'
    jacocoant 'org.jacoco:org.jacoco.ant:0.6.2.201302030002'
    antjunit 'org.apache.ant:ant-junit:1.8.4'
}


allprojects {
    apply plugin: 'idea'
    apply plugin: 'eclipse'
    apply plugin: 'java'

    configurations {
        codeCoverage
    }

    repositories {
        mavenCentral()
    }

    dependencies {
        compile fileTree(dir: new File(rootDir, 'libs'), include: '*.jar')
        compile 'org.jacoco:org.jacoco.agent:0.6.2.201302030002'
        codeCoverage group: 'org.jacoco', name: 'org.jacoco.agent', version: '0.6.2.201302030002', classifier: 'runtime'
    }

    test {
        jvmArgs "-javaagent:${configurations.codeCoverage.singleFile}=destfile=${rootDir}/coverage/jacoco.exec,sessionid=HSServ,append=true",
                '-Djacoco=true',
                '-Xms128m',
                '-Xmx512m',
                '-XX:MaxPermSize=128m'
    }
}

subprojects {

    dependencies {
        testCompile group: 'junit', name: 'junit', version: '4.+'
    }

    sourceCompatibility = 1.7
    targetCompatibility = 1.7
}


dependencies {
    compile project(':common')
    compile project(':crypto')
    compile project(':mixnet')
    compile project(':node')
}

task remove_libs << {
    File root = new File(projectDir, libsJarPath);
    if (root.exists()) {
        org.apache.commons.io.FileUtils.deleteDirectory(root);
        System.out.println(" Removed libs, use 'gradle fetch_libs' to reload.");
    }
}

task fetch_libs << {
    File root = new File(projectDir, libsJarPath);
    if (!root.exists()) {
        root.mkdirs();
    }
    fetchFile(providerRemoteUrl, root);
    fetchFile(pkixRemoteUrl, root);
}

task test_foo << {
    System.out.println(project(':common').file("build/lib/common.jar"));
}

task coverage_report(dependsOn: 'compileTestJava') << {

    //
    // Get jacoco jar.
    //
    File jacocoJar = null;
    project(':common').configurations.compile.each { file ->
        if (file.name.indexOf('jacoco') > 0) {
            jacocoJar = file;
        }
    }

    File root = new File(projectDir, "coverage");

    root.mkdirs();

    File coverageReport = new File(root, "reports");

    //
    // Delete old reports.
    //
    if (coverageReport.exists()) {
        org.apache.commons.io.FileUtils.deleteDirectory(coverageReport);
    }

    coverageReport.mkdirs();

    ant.taskdef(name: "jacocoreport", classname: "org.jacoco.ant.ReportTask", classpath: configurations.jacocoant.asPath);

    ant {
        jacocoreport {
            executiondata {
                fileset(dir: "${rootDir}/coverage/") {
                    file(file: 'jacoco.exec')
                }
            }

            structure(name: rootProject.name) {

                classfiles {
                    fileset dir: "${rootDir}/common/build/classes/main"
                    fileset dir: "${rootDir}/crypto/build/classes/main"
                    fileset dir: "${rootDir}/mixnet/build/classes/main"
                    fileset dir: "${rootDir}/node/build/classes/main"
                }

                // this is for Windows
                sourcefiles(encoding: 'UTF8') {
                    fileset dir: "${rootDir}/common/src/main/java"
                    fileset dir: "${rootDir}/crypto/src/main/java"
                    fileset dir: "${rootDir}/mixnet/src/main/java"
                    fileset dir: "${rootDir}/node/src/main/java"
                }
            }

            xml destfile: "${coverageReport}/ximix.xml"
            html destdir: "${coverageReport}"
        }
    }

    //
    // Delete source file..
    //
    new File("{$rootDir}/coverage/jacoco.exe").delete();


}


task make_node_installer(dependsOn: 'jar') << {


    Console console = System.console();

    boolean hasConfigs = true;
    File mixnetConfigFile = null;
    ArrayList<File> nodeConfigs = new ArrayList<File>();


    if (System.properties.containsKey("network")) {
        String[] paths = new String(System.properties["network"]).split(",");

        if (paths.length < 2) {
            System.err.println("\r\nThe mixnet config file and at least one node config file must be specified in the -Dnetwork property.");
            System.exit(-1);
        }

        mixnetConfigFile = new File(paths[0].trim());

        for (int t = 1; t < paths.length; t++) {
            nodeConfigs.add(new File(paths[t].trim()));
        }

        //
        // Check for file existence, structure and existence of one key node.
        //

        if (!mixnetConfigFile.exists() || mixnetConfigFile.isDirectory()) {
            System.err.println("Mixnet config file '" + mixnetConfigFile.getAbsolutePath() + "' does not exist or is a directory.");
            System.exit(-1);
        }

        if (!xmlFileStartsWith(mixnetConfigFile, "nodes")) {
            System.err.println("Mixnet config file '" + mixnetConfigFile.getAbsolutePath() + "' must contain a 'nodes' tag.");
            System.exit(-1);
        }


        for (File nodeFile : nodeConfigs) {
            if (!nodeFile.exists() || nodeFile.isDirectory()) {
                System.err.println("Node config file '" + nodeFile + "' does not exist or is a directory.");
                System.exit(-1);
            }
            if (!xmlFileStartsWith(nodeFile, "node")) {
                System.err.println("Node config file '" + nodeFile + "' must contain a 'node' tag");
                System.exit(-1);
            }
        }


    } else {

        println("\r\n\r\nConfiguration files can be nominated to be included in the installation.");
        println("\r\nUse:\r\ngradle make_node_installer -Dnetwork=<mixnet.xml>,<node1.xml>,<node2.xml> ... <nodeX.xml>");
        println("\r\nThe network property is a comma separated list of paths to: ");
        println("1. Mixnet Configuration <mixnet.xml>");
        println("2. Node configuration files <nodeX.xml>");
        println("\r\nExample:\r\ngradle make_node_installer -Dnetwork=mixnet.xml,node1.xml,node2.xml\r\n");
        println();
        println("When that property is set the task will generate an executable jar file that will create")
        println("separate complete node installations for each node.xml file specified.");
        println("The first file must be the mixnet.xml configuration that defines the mixnet and connection\r\ndetails concerning");
        println("each node.\r\n");
        println("See Wiki for more details.");
        println();

        String l = console.readLine("\r\nConfirm, generate a single node installer with NO inbuilt configuration: Yes, [No] >");
        if (!l.toLowerCase().contains("y")) {
            println("\r\nExiting installer generation.");
            System.exit(0);
        }

        hasConfigs = false;
    }


    println("\r\nMaking Node Installer Jar\r\n");

    File root = new File(projectDir, "build/installers");

    //
    // Final jar will go in here.
    //
    if (root.exists()) {
        org.apache.commons.io.FileUtils.deleteDirectory(root);
    }
    root.mkdirs();

    //
    // Stage for jar layout.
    //
    File installerJarStageDir = new File(root, "/stage");
    installerJarStageDir.mkdirs();

    //
    // Setup control file.
    //


    FileWriter sw = new FileWriter(new File(installerJarStageDir, "install.xml"));
    PrintWriter pw = new PrintWriter(sw);

    pw.println('<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>');
    pw.println('<installer>');
    pw.println('   <installation>');
    pw.println('        <name>Ximix</name>');
    pw.println('        <description></description>');
    pw.println('        <id>install_' + System.currentTimeMillis() + '</id>');
    pw.println('        <prop name="installDir" type="file" value="./"/>');
    pw.println('        <step name="askInstallLocation"/>');
    pw.println('        <movements>');
    pw.println('        <id>1</id>');


    if (hasConfigs) {
        for (int t = 0; t < nodeConfigs.size(); t++) {
            pw.println('            <movement src="node' + t + '/" recursive="true"></movement>');
        }
    } else {
        pw.println('            <movement src="node/" recursive="true"></movement>');
    }


    pw.println('        </movements>');
    pw.println('        <!-- Make executable if in a posix environment -->');

    if (hasConfigs) {
        for (int t = 0; t < nodeConfigs.size(); t++) {
            pw.println('        <posix-exec relpath="node' + t + '/bin/run.sh" perm="rwxr-xr-x"/>');
        }
    } else {
        pw.println('        <posix-exec relpath="node/bin/run.sh" perm="rwxr-xr-x"/>');
    }
    pw.println('   </installation>');
    pw.println('</installer>');


    pw.flush();
    pw.close();

    //  org.apache.commons.io.FileUtils.copyFile(new File(project(':installer').projectDir, "src/main/resources/install_node.xml"), new File(installerJarStageDir, "install.xml"));


    if (hasConfigs) {
        for (int t = 0; t < nodeConfigs.size(); t++) {
            populateNodeStage("node" + t, installerJarStageDir, mixnetConfigFile, nodeConfigs.get(t));
        }
    } else {
        populateNodeStage("node", installerJarStageDir, null, null);
    }

    //
    // This makes a node stand alone uses the ant jar task..
    //

    File jarFile = new File(root, "XimixNodeInstaller.jar");

    ant.jar(destfile: jarFile, manifest: new File(projectDir, "installer/manifest/MANIFEST.MF")) {
        fileset(dir: new File(projectDir, 'installer/build/classes/main/'));
        fileset(dir: installerJarStageDir);
    }


}


void populateNodeStage(String name, File installerJarStageDir, File mixnetConfig, File nodeConfig) {
    File nodeStageDir = new File(installerJarStageDir, name);

    //
    // Add in configs.
    //

    File confDir = new File(nodeStageDir, "conf/");
    confDir.mkdirs();

    //
    // Config files are copied into place and renamed to default names.
    //
    if (mixnetConfig != null) {
        org.apache.commons.io.FileUtils.copyFile(mixnetConfig, new File(confDir, "mixnet.xml"));
    }

    if (nodeConfig != null) {
        org.apache.commons.io.FileUtils.copyFile(nodeConfig, new File(confDir, "node.xml"));
    }

    //
    // Libs.
    //

    File stagedLibs = new File(nodeStageDir, "/libs");
    stagedLibs.mkdirs();

    org.apache.commons.io.FileUtils.copyFileToDirectory(project(':common').jar.archivePath, stagedLibs);
    org.apache.commons.io.FileUtils.copyFileToDirectory(project(':crypto').jar.archivePath, stagedLibs);
    org.apache.commons.io.FileUtils.copyFileToDirectory(project(':mixnet').jar.archivePath, stagedLibs);
    org.apache.commons.io.FileUtils.copyFileToDirectory(project(':node').jar.archivePath, stagedLibs);

    //
    // The two betas.
    //

    org.apache.commons.io.FileUtils.copyDirectory(new File("${rootDir}/libs/"), stagedLibs);


    org.apache.commons.io.FileUtils.copyDirectory(new File(project(':installer').projectDir, "includes/node/"), nodeStageDir);
}

/**
 * Fetch a file at url and save it into the directory.
 * The filename used is taken from the url.
 */
void fetchFile(String url, File directory) {
    URL u = new URL(url);
    String f = u.getFile();
    f = f.substring(f.lastIndexOf("/") + 1);
    System.out.print("Fetching '" + f + "' from '" + url + "' ... ");
    org.apache.commons.io.FileUtils.copyURLToFile(u, new File(directory, f));
    System.out.println("Complete");
}


boolean xmlFileStartsWith(File path, String nodename) {
    try {
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();
        Document doc = docBuilder.parse(path);

        Element xmlNode = doc.getDocumentElement();

        if (nodename.equals(xmlNode.getNodeName())) {
            return true;
        }


        NodeList nl = xmlNode.getChildNodes()
        for (int t = 0; t < nl.length; t++) {
            if (nodename.equals(nl.item(t).getNodeName())) {
                return true;
            }
        }
    }
    catch (Exception ex) {
        System.out.println(ex.getMessage());
    }

    return false;
}